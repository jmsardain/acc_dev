// Copyright (C) 2002-2019 CERN for the benefit of the ATLAS collaboration

#ifndef HTTConstGenAlgo_h
#define HTTConstGenAlgo_h

/**
 * @file HTTConstGenAlgo.h
 * @author Unknown; major rewrite Riley Xu - riley.xu@cern.ch
 * @date May 28th, 2020
 * @brief Algorithm to generate fit constants.
 *
 * This algorithm inputs matrix files generated by HTTMatrixGenAlgo,
 * and outputs ROOT/text files containing the fit constants used by HTT to fit
 * tracks. Each sector contains the information in geo_constants struct declared
 * below.
 *
 * See ATLAS-TDR-FTK-021 section 5.2.2. for a detailed description of constant generation.
 * The constants are calculated via equation 9,
 *
 *      C_ij = Inv(V_jk) . ( <x_k p_i> - <x_k> <p_i> )
 *
 * where x_k are the hit coordinates, p_i the helix parameters, and V_jk the covariance matrix
 *
 *      V_jk = <x_j x_k> - <x_j> <x_k>
 */

#include "GaudiKernel/ITHistSvc.h"
#include "AthenaBaseComps/AthAlgorithm.h"
#include "TrigHTTUtils/HTTVectors.h"
#include "TrigHTTUtils/HTTMacros.h"
#include "TrigHTTMaps/ITrigHTTMappingSvc.h"
#include "TrigHTTMaps/HTTPlaneMap.h"
#include "TrigHTTByteStream/TrigHTTHardwareConversionTool.h"
#include "TTree.h"
#include "TrigHTTBankGen/HTTMatrixAccumulator.h"

#include <string>
#include <vector>

#include "TTree.h"
#include "TH1I.h"
#include "TH1F.h"

class ITrigHTTMappingSvc;


// data structure that contain definition of geometrical constants for linear fits
struct geo_constants
{
    //these are the matrices themselves
    std::vector<double> Vd0; // impact paramers coefs
    std::vector<double> Vcurvature; // curvature coefs
    std::vector<double> Vphi; // phi coefs
    std::vector<double> Vz0; // z0 coefs
    std::vector<double> Veta; // eta coefs
    vector2D<double>    kernel; // kernel (covariance matrix). Size (ndim - npar, ndim)
    std::vector<double> kaverages; // averages, useful to keep track of

    // these are the constant/offset values
    HTTTrackPars pars;

    int real; // this value is greater than 0 if these constants are correctly evaulated

    geo_constants(size_t nCoords) :
        Vd0(nCoords),
        Vcurvature(nCoords),
        Vphi(nCoords),
        Vz0(nCoords),
        Veta(nCoords),
        kernel(nCoords - HTTTrackPars::NPARS, nCoords),
        kaverages(nCoords - HTTTrackPars::NPARS),
        pars(0),
        real(0)
    {
    }
};


class HTTConstGenAlgo : public AthAlgorithm
{
    public:

        HTTConstGenAlgo(const std::string& name, ISvcLocator* pSvcLocator);
        virtual ~HTTConstGenAlgo() = default;
        StatusCode initialize() override;
        StatusCode execute() override;
        StatusCode finalize() override;
        StatusCode bookHistograms();

    private:

        ///////////////////////////////////////////////////////////////////////
        // Handles

        ServiceHandle<ITrigHTTMappingSvc> m_HTTMapping;
        ServiceHandle<ITHistSvc> m_tHistSvc;
        const HTTPlaneMap* m_pmap;
        ToolHandle<TrigHTTHardwareConversionTool> m_hardwareConversionTool; // input handler

        ///////////////////////////////////////////////////////////////////////
        // Configuration

        std::string m_cfpath;
        std::string m_skipFile;
        BooleanProperty m_Monitor = false;
        int m_region = 0;
        bool m_CheckGood2ndStage;
        bool m_useHitScaleFactor;
    	bool m_isSecondStage;
    	bool m_dumpMissingHitsConstants; // if this is true we dump constants assuming a missing hit in each layer, too
    	bool m_dumpHardwareConstants; // do we want to also dump HW constants in float->binary->hex format?

        ///////////////////////////////////////////////////////////////////////
        // ROOT Objects

        TFile *mafile;
        TTree *m_ctree;
        TTree *matrix_tree;
        TTree *good_tree;

        TH1F *h_vc;
        TH1F *h_vd;
        TH1F *h_vf;
        TH1F *h_vz;
        TH1F *h_veta;

        ///////////////////////////////////////////////////////////////////////
        // Slice Info

        HTTTrackParsI m_sliceNBins;
        HTTTrackPars m_sliceMin;
        HTTTrackPars m_sliceMax;

        ///////////////////////////////////////////////////////////////////////
        // Sizes

        int m_nLayers;
        int m_nKernel;
        int m_nKAverages;
        int m_nCoords;
        int m_nCoords_2; // m_nCoords^2


        ///////////////////////////////////////////////////////////////////////
        // Main Storage Objects

        // These have size = # of good sectors.
        std::vector<geo_constants> m_geo_consts;

        // These are the constants for missing hits, first index is missing hit
        // The second index is the same as above (good sector number)
        std::vector<std::vector<geo_constants>> m_geo_consts_with_missinghit;

        // Size = # of sectors. Which sectors to skip for generating constants.
        std::vector<bool> m_skipList;

        ///////////////////////////////////////////////////////////////////////
        // Helper Functions

        StatusCode copySliceTree(TFile *file);
        StatusCode prepareOutputTree();
        void readSkipList(size_t nEntries);
        void generate_constants();
        void fillConstTree(std::vector<module_t> & modules, HTTMatrixAccumulator & acc, geo_constants & geo);
        bool isNAN(double value, const char* name);
        bool failedConstants(geo_constants const & geo, std::vector<bool> const & usable);
        void DumpConstants(std::vector<geo_constants> &geo_consts, std::string filename, bool HW = false);
        void writeSectors();
        bool GetConstants(HTTMatrixAccumulator const &acc_norm, geo_constants &geo, int entryNumber); // use values in acc_norm
        bool GetConstants(HTTMatrixAccumulator const &acc_norm, geo_constants &geo, int entryNumber, std::vector<bool> const &coordsToUse, unsigned int nusable); // full method with different number of usable coordinates
        void createMissingHitsConstants(HTTMatrixAccumulator const & acc_norm, size_t entry);


};

#endif // HTTConstGenAlgo_h


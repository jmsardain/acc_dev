#ifndef HTTPATTGENTOOLBASE_H
#define HTTPATTGENTOOLBASE_H

/**
 * @file HTTPattGenToolI.h
 * @author Riley Xu - rixu@cern.ch
 * @date 10/25/19
 * @brief Declares an abstract class that implements an interface for pattern generation.
 *
 * This class is implemented in
 *      HTTPattGenTool_Truth.h
 *      HTTPattGenTool_TI.h
 */

#include "AthenaKernel/IAtRndmGenSvc.h"
#include "AthenaBaseComps/AthAlgTool.h"
#include "TrigHTTMaps/ITrigHTTMappingSvc.h"
#include "TrigHTTUtils/HTTTypes.h"
#include "TrigHTTUtils/HTTMacros.h"
#include "TrigHTTMaps/HTTSSMap.h"
#include "TrigHTTBanks/ITrigHTTBankSvc.h"
#include "TrigHTTObjects/HTTPattern.h"

#include "CLHEP/Random/RandFlat.h"
#include "CLHEP/Random/RandGauss.h"

class HTTSectorBank;


static const InterfaceID IID_HTTPattGenToolI("HTTPattGenToolI", 1, 0);


/*
 * HTTPattGenToolI declares and defines the interface for pattern generation.
 * This abstract base class handles initializing properties, selecting patterns from candidates,
 * tracking metadata, and implementing the interface.
 *
 * Usage: This class generates patterns iteratively from calls to next(). The
 * generated pattern can be retrieved with getPattern().
 *
 *      Job options:
 *          PG = HTTPattGenTool_XXX()
 *          ...other optional and derived-class properties...
 *
 *      Code:
 *          ToolHandle<HTTPattGenToolI> m_pattGen;
 *          ErrorStatus es = m_pattGen->next();
 *          HTTPattern & p = m_pattGen->getPattern();
 *
 *
 * The only purely virtual function is nextCandidates(). Implementations of
 * PattGen only need to implement nextCandidates(), which
 * returns a newly generated pattern and multiple possible sectors that match it.
 */
class HTTPattGenToolI : public AthAlgTool
{
    public:

        ///////////////////////////////////////////////////////////////////////
        // AthAlgTool
        HTTPattGenToolI(const std::string&, const std::string&, const IInterface*);
        virtual ~HTTPattGenToolI() = default;

        static const InterfaceID& interfaceID() { return IID_HTTPattGenToolI; }
        virtual StatusCode initialize();

        ///////////////////////////////////////////////////////////////////////
        // Configuration (preferably set using job options)

        // Set maximum number of wildcards in a pattern. Default: 2
        inline void setMaxWC(size_t n) { m_maxWCs = n; }
        inline size_t getMaxWC() const { return m_maxWCs; }

        // list.size() == nLayers. Set which layers are allowed to have wildcards. Default: all true.
        void setWCAllowed(std::vector<bool> const & list);

        inline size_t getNLayers() const { return m_nLayers; }

        ///////////////////////////////////////////////////////////////////////
        // Generation

        // Generates the next pattern, which can be accessed by getPattern().
        // Returns ES_OK on success. See .cxx for other return codes.
        ErrorStatus next();

        // Gets the pattern generated by a call to next(). Will return an old pattern
        // if next() returned !ES_OK, and an invalid pattern if next() is not called
        // first.
        inline HTTPattern const & getPattern() const { return m_pattern; }

        // Gets the number of wildcards in the pattern returned by getPattern().
        // Same as getPattern().nWildcards() but is cached. It is also valid
        // if next() return ES_CONSTRAINT, whereas getPattern() is not.
        inline size_t const & getNWC() const { return m_pattWCs; }

    protected:

        ///////////////////////////////////////////////////////////////////////
        // Properties

        ServiceHandle<ITrigHTTMappingSvc> m_HTTMapping;
        ServiceHandle<ITrigHTTBankSvc> m_HTTBankSvc;
        ServiceHandle<IAtRndmGenSvc> m_rndmSvc;

        size_t m_nLayers = 0; // alias to m_HTTMapping->PlaneMap1stStage()->getNLogiLayers();
        size_t m_maxWCs = 2; // maximum number of wildcards allowed in a pattern
        std::vector<bool> m_WCAllowed;
            // if a wildcard is allowed in a given layer
            // defaults to true for all layers

        ///////////////////////////////////////////////////////////////////////
        // Other Variables

        size_t m_iter = 0; // total number of iterations done so far

        ///////////////////////////////////////////////////////////////////////
        // Reference Objects - these are not owned by the class.

        CLHEP::RandFlat *m_rndFlat;
        CLHEP::RandGauss *m_rndGauss;
        HTTSectorBank *m_sectorBank = nullptr; // alias to m_HTTBankSvc->SectorBank();

        ///////////////////////////////////////////////////////////////////////
        // Helpers

        // Returns a pattern with multiple possible sectors that match it.
        // Sectors with the minimum number of layers missed (i.e. don't match the pattern)
        // are returned, with misses replaced by wildcards. This number of layers
        // missed is also returned by reference.
        virtual ErrorStatus nextCandidates(std::vector<HTTPattern> & pattCands, size_t & layersMissed) = 0;

        inline double getRandom() const { return m_rndFlat->fire(); }
        inline double getRandomGaus() const { return m_rndGauss->fire(); }
        inline const HTTPlaneMap* pmap() const { return m_HTTMapping->PlaneMap_1st(); }

    private:

        ///////////////////////////////////////////////////////////////////////
        // Properties

        std::string m_rndStreamName = "RANDOM";

        ///////////////////////////////////////////////////////////////////////
        // Last generated pattern storage

        HTTPattern m_pattern; // stores the result of calling next()
        size_t m_pattWCs;     // number of wildcards in m_pattern (cached for convenience)

        ///////////////////////////////////////////////////////////////////////
        // Helpers

        StatusCode readSectorFile(const std::string& sectorfile);
        HTTPattern const & selectPattern(std::vector<HTTPattern> const & pattCands) const;
};






#endif
